{"ast":null,"code":"\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n  if (callbackArgIndex === void 0) {\n    callbackArgIndex = void 0;\n  }\n\n  return function () {\n    var thisCallbackArgIndex;\n\n    if (callbackArgIndex === void 0) {\n      // istanbul ignore next\n      thisCallbackArgIndex = arguments.length > 0 ? arguments.length - 1 : 0;\n    } else {\n      thisCallbackArgIndex = callbackArgIndex;\n    }\n\n    var callbackArg = arguments[thisCallbackArgIndex];\n\n    if (typeof callbackArg === 'function') {\n      fn.apply(context, arguments);\n      return void 0;\n    } else {\n      var args_1 = []; // If an explicit callbackArgIndex is set, but the function is called\n      // with too few arguments, we want to push undefined onto args so that\n      // our constructed callback ends up at the right index.\n\n      var argLen = Math.max(arguments.length, thisCallbackArgIndex);\n\n      for (var i = 0; i < argLen; i++) {\n        args_1.push(arguments[i]);\n      }\n\n      return new Promise(function (resolve, reject) {\n        args_1.push(function (err, result) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n        fn.apply(context, args_1);\n      });\n    }\n  };\n}\n\nmodule.exports = callbackToPromise;","map":{"version":3,"sources":["../src/callback_to_promise.ts"],"names":[],"mappings":";AAAA;;;;;AAKG;;AACH,SAAS,iBAAT,CAA2B,EAA3B,EAA+B,OAA/B,EAAwC,gBAAxC,EAAiE;AAAzB,MAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,gBAAA,GAAA,KAAwB,CAAxB;AAAyB;;AAC7D,SAAO,YAAA;AACH,QAAI,oBAAJ;;AACA,QAAI,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAC7B;AACA,MAAA,oBAAoB,GAAG,SAAS,CAAC,MAAV,GAAmB,CAAnB,GAAuB,SAAS,CAAC,MAAV,GAAmB,CAA1C,GAA8C,CAArE;AACH,KAHD,MAGO;AACH,MAAA,oBAAoB,GAAG,gBAAvB;AACH;;AACD,QAAM,WAAW,GAAG,SAAS,CAAC,oBAAD,CAA7B;;AACA,QAAI,OAAO,WAAP,KAAuB,UAA3B,EAAuC;AACnC,MAAA,EAAE,CAAC,KAAH,CAAS,OAAT,EAAkB,SAAlB;AACA,aAAO,KAAK,CAAZ;AACH,KAHD,MAGO;AACH,UAAM,MAAI,GAAG,EAAb,CADG,CAEH;AACA;AACA;;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,SAAS,CAAC,MAAnB,EAA2B,oBAA3B,CAAf;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAC7B,QAAA,MAAI,CAAC,IAAL,CAAU,SAAS,CAAC,CAAD,CAAnB;AACH;;AACD,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC/B,QAAA,MAAI,CAAC,IAAL,CAAU,UAAC,GAAD,EAAM,MAAN,EAAY;AAClB,cAAI,GAAJ,EAAS;AACL,YAAA,MAAM,CAAC,GAAD,CAAN;AACH,WAFD,MAEO;AACH,YAAA,OAAO,CAAC,MAAD,CAAP;AACH;AACJ,SAND;AAOA,QAAA,EAAE,CAAC,KAAH,CAAS,OAAT,EAAkB,MAAlB;AACH,OATM,CAAP;AAUH;AACJ,GAhCD;AAiCH;;AAED,MAAA,CAAA,OAAA,GAAS,iBAAT","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n    if (callbackArgIndex === void 0) { callbackArgIndex = void 0; }\n    return function () {\n        var thisCallbackArgIndex;\n        if (callbackArgIndex === void 0) {\n            // istanbul ignore next\n            thisCallbackArgIndex = arguments.length > 0 ? arguments.length - 1 : 0;\n        }\n        else {\n            thisCallbackArgIndex = callbackArgIndex;\n        }\n        var callbackArg = arguments[thisCallbackArgIndex];\n        if (typeof callbackArg === 'function') {\n            fn.apply(context, arguments);\n            return void 0;\n        }\n        else {\n            var args_1 = [];\n            // If an explicit callbackArgIndex is set, but the function is called\n            // with too few arguments, we want to push undefined onto args so that\n            // our constructed callback ends up at the right index.\n            var argLen = Math.max(arguments.length, thisCallbackArgIndex);\n            for (var i = 0; i < argLen; i++) {\n                args_1.push(arguments[i]);\n            }\n            return new Promise(function (resolve, reject) {\n                args_1.push(function (err, result) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(result);\n                    }\n                });\n                fn.apply(context, args_1);\n            });\n        }\n    };\n}\nmodule.exports = callbackToPromise;\n//# sourceMappingURL=callback_to_promise.js.map"]},"metadata":{},"sourceType":"script"}